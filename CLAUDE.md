# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Principles

- **Transparency & Inspectability**: This project prioritises open, end-user inspectable code. Users should be able to debug and analyse the client-side logic using browser DevTools. Source maps are enabled for production builds to expose original TypeScript. Avoid obfuscation or minification techniques that would hinder user inspection.
- **Simplicity**: Prefer minimal dependencies and straightforward implementations.
- **Offline-first**: All functionality must work without network access after initial load.

## Git Workflow

**IMPORTANT**: Never push directly to `main`. Always create a feature branch and open a pull request for review.

1. Create a feature branch: `git checkout -b feature/description`
2. Make commits on the feature branch
3. Push the branch: `git push -u origin feature/description`
4. Create a pull request via `gh pr create`
5. Wait for review and approval before merging

## Project Overview

Study Buddy is a Progressive Web Application (PWA) built with TypeScript and Vite. It is designed to work completely offline with no backend server beyond static file hosting. All data persistence is handled client-side using two storage systems:

- **IndexedDB** - For unstructured data, documents, and binary content
- **SQLite (via sql.js)** - For structured relational data with complex queries

## Project Documentation

**IMPORTANT**: All project documentation is in the root directory (NOT in node_modules):

- **DB_DEVELOPMENT.md** - Database architecture decisions, design rationale, and patterns
- **QUESTION_TYPES_PLAN.md** - Plan for current and future question types
- **CLAUDE.md** (this file) - Development setup and architecture overview

Never edit files in `node_modules/` - those are external library files.

## Development Commands

Install dependencies:
```bash
npm install
```

Start development server:
```bash
npm run dev
```

Build for production:
```bash
npm run build
```

Preview production build:
```bash
npm run preview
```

Type check:
```bash
npm run type-check
```

Lint code:
```bash
npm run lint
```

## Architecture

### Storage Layer

The application uses a dual-storage strategy:

**IndexedDB** (`src/storage/indexeddb.ts`):
- Managed via the `idb` library for a Promise-based API
- Database name: `study-buddy-db`
- Stores: `notes` (with date index), `sqliteData` (for SQLite persistence)
- All operations are async
- Use `initDB()` or `getDB()` before database operations

**SQLite** (`src/storage/sqlite.ts`):
- Uses sql.js (SQLite compiled to WebAssembly)
- Database persisted to IndexedDB (with auto-migration from legacy localStorage)
- Call `saveDB()` after write operations to persist changes
- Use `execAndSave()` for automatic persistence
- Use `query()` for SELECT operations that return objects
- Database can be exported/imported as Uint8Array for backup

### PWA Configuration

Service worker and manifest are automatically generated by `vite-plugin-pwa`:
- Configuration in `vite.config.ts`
- Caches all static assets (js, css, html, wasm)
- Runtime caching for external resources
- Auto-update strategy with user prompt

### Entry Point

`src/main.ts` is the application entry point:
- Registers service worker
- Initializes both storage systems
- Renders initial UI

## Key Patterns

**Adding new IndexedDB stores:**
1. Update `StudyBuddyDB` interface in `src/storage/indexeddb.ts`
2. Increment database version in `openDB` call
3. Add store creation logic in `upgrade` callback
4. Add helper functions for new store operations

**Adding new SQLite tables:**
1. Add CREATE TABLE statement in `initSQLite()` function
2. Tables are created automatically on first run
3. Use `execAndSave()` for INSERT/UPDATE/DELETE operations
4. Use `query()` for SELECT operations

**Storage system selection:**
- Use IndexedDB for: user documents, notes, media, settings
- Use SQLite for: relational data, data requiring joins, time-series data, analytics

**Question System Architecture:**
- Questions use a parallel table structure - each question type has its own tables
- Core `questions` table contains only essential cross-cutting data
- Tagging system is shared across all question types via `tags` and `question_tags` tables
- See `DB_DEVELOPMENT.md` for detailed architecture decisions
- See `QUESTION_TYPES_PLAN.md` for implementing new question types

**Shared Components:**
- `src/storage/tags.ts` - Tag management (used by all question types)
- `src/components/tagSelector.ts` - Reusable tag selector UI component

## Development Practices

**Tools are the source of truth**: When in doubt, run the actual tools rather than making assumptions or trusting potentially stale IDE diagnostics:
```bash
npm run type-check  # Verify TypeScript compiles
npm run lint        # Verify ESLint passes
npm run build       # Verify production build works
```
Run these after changes to catch errors early. If you're unsure whether something is working, verify with the tool - don't guess.

**Safe HTML templating**: Use the `html` tagged template from `src/utils/html.ts` for innerHTML assignments:
- `html``...`` - Auto-escapes interpolated values to prevent XSS
- `raw(str)` - Mark pre-escaped HTML to prevent double-escaping
- `attr(str)` - Escape for attribute values (handles quotes)

Example:
```typescript
import { html, raw, attr } from '../utils/html';

const items = data.map(d => html`<li>${d.name}</li>`).join('');
element.innerHTML = html`
  <ul>${raw(items)}</ul>
  <input value="${attr(userInput)}">
`;
```

## Cloudflare Pages Deployment

The app is configured for Cloudflare Pages deployment via `wrangler.jsonc`:
- Build command: `npm run build`
- Output directory: `dist`
- Static assets are served directly (no Functions/Workers)

Local preview (note: may have issues on Windows/WSL):
```bash
npm run cf:preview
```

## Important Notes

- SQL.js loads from CDN (`https://sql.js.org/dist/`), ensure this is accessible
- SQLite database is persisted to IndexedDB (`sqliteData` store)
- Always call `saveDB()` after SQLite write operations to persist changes
- The app works completely offline after first load
- Service worker caching includes `.wasm` files for sql.js
